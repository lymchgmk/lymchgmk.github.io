---
layout: post
title:  "예제로 공부하는 Java 100 문제풀이 Summary"
summary: "Inflearn / Java 100"
author: lymchgmk
date: '2022-01-14 00:36:00 +0900'
category: Inflearn
thumbnail: /assets/img/posts/Java_logo.jpg
keywords: post
permalink: /blog/inflearn-java-100-Summary
usemathjax: false
comments: true
---

# 예제로 공부하는 Java 100 문제풀이 Summary

## Part.1 

### Ch 1. 환경설정

1. 컴파일 언어 vs 인터프리터 언어

   - 컴파일 언어: Java 코드 작성(.java) -> javac가 .java파일을 Compile(.class) -> java VM이 Run

     - 전체 소스코도를 보고 / 명령어를 수집하고 / 재구성
     - 전체 소스코드 변환 후 에러를 보고. 보안적으로 단점.

   - 인터프리터 언어: Python 코드 작성(.py) -> Run

     - 소스코드의 각 행을 연속적으로 분석하며 실행
     - 각 행마다 실행하며 도중 에러가 보고되면 이후 코드를 안봄. 보안적으로 장점.

   - 사실, Java는 컴파일러와 인터프리터 모두 사용.

     ![image-20220114010211902](C:\Users\lymch\AppData\Roaming\Typora\typora-user-images\image-20220114010211902.png)

     - 컴파일러는 빠르지만 프로그램이 작성된 하드웨어의 종류에 종속되기 때문에, 플랫폼에 종속되지 않는 인터프리팅의 장점을 취하기 위한 구조.
     - Java 바이트 코드(.class) 파일은 컴퓨터와 프로그램 사이에 별도의 버퍼역할. 이는 보안적으로 장점.



### Ch 2. 변수

1. 접근제한자(접근제어자): `public` > `protected` > `(default)` > `private`

2. 변수 표기법

   - 카멜 표기법: camelCase
     - 앞 단어를 제외한 단어의 첫 글자를 대문자로 표기
     - Java, C#
   - 파스칼 표기법: PascalCase
     - 모든 단어의 첫 글자를 대문자로 시작
     - Class, NameSpace, Event, Property등을 지정할 때 주로 사용
       - 특히 Class 이름
   - 스테이트 표기법: snake_case
     - 모든 단어를 소문자로 표기하고 단어 사이에 언더바를 붙임
     - 언더바 표기법이라고도 함
     - C++
   - 헝가리안 표기법: strHungarianCase
     - 접두어에 자료형을 붙임
       - 현재는 자료형을 쉽게 알아보기 쉬워서 + 데이터 타입이 바뀌면 변수/함수 이름을 다시 바꿔줘야해서 권장하지 않음

3. 리틀 엔디안 vs 빅 엔디안

   - 연속되는 바이트 저장 순서에 대한 방식
   - 빅 엔디안: 낮은 주소에 데이터의 높은 바이트부터 저장하는 방식
     - ex) 0x12345678 -> 0x12, 0x34, 0x56, 0x78 -> 낮은 주소 ~ 높은 주소
     - RISC CPU 계열, 네트워크 통신에서 사용.
   - 리틀 엔디안: 낮은 주소에 낮은 바이트부터 저장하는 방식
     - ex) 0x12345678 -> 0x78, 0x56, 0x34, 0x12
     - 대부분의 인텔 CPU에서 사용.
   - 리틀 엔디안 vs 빅 엔디안
     - 물리적으로 데이터를 조작하거나 산술 연산을 수행할 때에는 리틀 엔디안이 더 효율적
       - 대부분의 시스템은 인텔 기반이라 리틀 엔디안
     - 데이터의 각 바이트를 배열처럼 취급할 때는 빅 엔디안
       - 네트워크를 통해 데이터를 전송할 때는 빅 엔디안

4. `static`: 메모리의 Heap영역이 아닌 Static영역에 할당, 모든 객체가 공유할 수 있으나, Garbage Collections의 관리 영역 밖이라 프로그램이 끝날때까지 메모리가 할당됨.

   - 변수
     - 메모리 할당을 딱 한 번만 하는 메모리 이점
     - 같은 메모리 주소이므로 값 공유 가능

   - 메서드

     - 객체 생성없이 `class`를 통해 메서드를 직접 호출 가능
       - 보통 유틸리티성 메소드에 사용. ex) 숫자에 콤마 추가하기

   - 싱글톤 패턴 (Singleton pattern): 단 하나의 객체만 생성하게 강제하는 패턴

     ```Java
     class Singleton {
         private static Singleton one;
         private Singleton() {
         }
     
         public static Singleton getInstance() {
             if(one==null) {
                 one = new Singleton();
             }
             return one;
         }
     }
     
     public class Sample {
         public static void main(String[] args) {
             Singleton singleton1 = Singleton.getInstance();
             Singleton singleton2 = Singleton.getInstance();
             System.out.println(singleton1 == singleton2);  // true 출력
         }
     }
     ```

5. Java의 데이터 타입

   1. 기본형 타입(Primitive Type): 4종류 4 + 2 + 1 + 1 = 8개
      - 정수형: byte, short(2 byte), int(4 byte), long(8byte)
      - 실수형: float(4 byte), double(8 byte)
      - 문자형: char(2 byte)
      - 부울형: boolean(1 byte)
   2. 참조형 타입(Reference Type): 기본형이 아닌 것들. 데이터가 저장된 메모리의 주소 값을 통해 데이터를 불러옴.
      - Class, Array, String, Interface



### Ch 3. 연산자

1. 나숫셈 연산에서 둘 중 하나라도 실수형이면 결과값도 실수형으로 나옴.
2. 삼항연산자: `변수 = 조건 ? true : false`



## Part 2.

### Ch 1. 반복문

1. for / 향상된 for 문 / while / do ~ while



### Ch 2. 배열

1. 배열 선언: 둘 다 가능
   - `int arr [] = new int[]`
   - `int[] arr = new int[]`
2. Java에서는 그냥 변수를 print하면 주소값이 출력됨
3. 배열의 값을 한 번에 출력: `Arrays.toString(arr)` 
4. 다중 배열 선언: `int[] a, b, c;`
5. 배열 복사: `System.arraycopy(소스배열, 소스배열 시작 idx, 타깃배열, 타깃배열 시작 idx, 복사할 원소 수)`



## Part 3.

### Ch 1. 메서드

1. `static`메서드여야 `public static void main(String[] args)`에서 호출 가능.
2. `static`메서드가 아니지만 `main`메서드에서 사용하려면, `class`객체를 생성해서 메서드를 사용해야 함.
3. `Call by value` vs `Call by reference`
   - `Call by value`: 값을 복사하여 처리, 원래의 값이 보존됨 / 메모리 사용량 늚
   - `Call by reference`: 값을 복사하지 않고 직접 참조. 빠름 / 원래 값이 영향을 받는 리스크
   - `Java`에서는 `Call by value`방식을 사용.
     - 단, `Reference Type` 데이터는 객체의 주소값을 참조하기 때문에 당연히 `Call by reference`로 작동.
4. `Wrapper` 클래스: `Primitive Type` 데이터를 객체로 취급하기 위해 사용하는 클래스
   - 박싱(Boxing): `Primitive Type`을 `Wrapper`클래스로 변환
   - 언박싱(Unboxing): `Wrapper`클래스를 `Primitive Type`으로 변환
   - 단, `Java 1.5`부터 오토 박싱 & 오토 언박싱을 자바 컴파일러가 자동으로 처리
5. 

