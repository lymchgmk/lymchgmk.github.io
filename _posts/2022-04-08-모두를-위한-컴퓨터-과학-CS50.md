---
layout: post
title:  "모두를 위한 컴퓨터 과학 (CS50)"
summary: "Boostcourse / CS50"
author: lymchgmk
date: '2022-04-08 16:01:00 +0900'
category: Study
thumbnail: /assets/img/posts/CS50.png
keywords: Boostcourse
permalink: /blog/CS50
usemathjax: false
comments: true

---

# 모두를 위한 컴퓨터 과학 (CS50 2019)

## 1. 컴퓨팅 사고

### 1) 2진법

>  컴퓨터는 트랜지스터로 이루어져있고, 이 때문에 모든 데이터는 0과 1로 표현된다.



#### 컴퓨터 과학

> 문제 해결에 대한 학문. 입력을 전달받아 출력을 만들어내는 과정

- 입출력을 표현하기 위해 모두가 동의하는 표준이 필요.



#### 2진법

> 컴퓨터는 오로지 0과 1만으로 글자, 사진, 영상, 소리 등을 저장할 수 있음



#### 비트

> "binary digit", 0과 1, 두 가지 값만 가질 수 있는 측정 단위



#### 비트열

> 여러 숫자 조합을 컴퓨터에 나타내기 위한 비트의 모음

![img](D:\GITHUB\lymchgmk.github.io\assets\img\posts\CS50\1-1.png)



#### *생각해보기*

- *Q) 5를 2진법으로 바꿔보면 어떻게 될까요?*
  - *A) 101 (2)*





### 2) 정보의 표현

> 컴퓨터가 문자, 사진, 영상, 음악 등 다양한 정보를 처리하는 방식



#### 문자의 표현

> 문자를 숫자로 표현할 수 있도록 정해진 표준

- ASCII

  ![img](D:\GITHUB\lymchgmk.github.io\assets\img\posts\CS50\1-2.png)

  - A: 65로 시작하는 패턴. 미국의 규약. 당시 8bit만 사용한 한계.

- 유니코드
  - ASCII의 상위 조합. 이모티콘 포함. 32bit까지 사용.



#### 그림, 영상, 음악의 표현

> 그림, 영상, 음악은 어떻게 숫자로 표현하는가

- RGB
  - 이모티콘같은 이미지를 표현하기 위한 체계. RGB 3색을 조합하여 어떤 색이든 만들 수 있기 때문.
  - GIF같은 움직이는 이미지, 동영상도 마찬가지.
- ETC
  - 음악도 마찬가지로 양자화 가능. 음, 길이, 음량같은 정보를 0과 1로 표현.



#### *생각해보기*

- *Q) CS50을 2진법으로 표현해보세요*
  - *A) ASCII코드를 이용한 4자리 문자열로 생각한다면, 각각 십진수 67, 83, 53, 48에 해당하고, 이는 각각 이진수 1000011, 1010011, 1010101, 110000로 변환됨*





### 3) 알고리즘

> 일생 생활의 일을 컴퓨터가 이해할 수 있는 알고리즘으로 표현하고, 효율에 대해 설명



#### 알고리즘

> 입력값을 출력값으로 변환하기 위해 수행해야 하는 명령들의 순서적 나열

![algorithms](D:\GITHUB\lymchgmk.github.io\assets\img\posts\CS50\1-3.png)



#### 정확한 알고리즘

> 알고리즘을 평가할 때는 정확성과 효율성이 중요

- 전화번호에서 "Mike Smith"를 찾는 방법
  - 1. 첫 장부터 마지막 장까지 조회하는 방법을 옳지만 느리다.
    2. 두 장 씩 넘기는 것은 놓칠 수 있어서 틀리다.
  
- 사용자가 가지고 있는 직관이나 아이디어를 컴퓨터가 이해할 수 있는 방식으로 작성하는 것.
  - 이를 수도코드로 작성하고, 프로그래밍 언어로 만들면 됨.



#### 정확하고 효율적인 알고리즘

> 정확하다면 효율이 좋을 수록 좋다

- 이분탐색



#### 의사코드

> 필요한 행동이나 조건을 잘 설정하여 파악하기 위한 코드

- 함수
- 조건
  - 불리언
- 루프



#### *생각해보기*

- *Q) 친구와 1부터 100까지 숫자 중 1가지 숫자를 맞추는 스무고개 게임을 하려고 합니다. 이 때 사용할 알고리즘을 의사코드로 표현하면 어떻게 될까요?*

  - *A)*

    ```
    start, end = 1, 100
    target = 50
    while target != answer:
    	if target > answer:
    		end = target
    	else:
    		start = target
    	target = (end + start) // 2
    
    print(target)
    ```





### 4) 스크래치: 기초

> MIT에서 개발한 그래픽 프로그래밍 언어.

- 블럭을 이용해서, 입력과 출력을 이어 붙여 순차적인 작업을 수행.



### 5) 스크래치: 심화

- 스크래치를 이용해 보다 복잡한 알고리즘 구현







## 2. C언어

### 1) C 기초

> CS50 Sandbox를 이용해 Hello, world! 출력



#### C언어

> 아주 오래되고 전통적인 순수 텍스트 기반의 언어

```c
#include <stdio.h>

int main(void)
{
	printf("Hello, world!");
}
```



#### 컴파일러

> 소스 코드를 머신 코드로 변환하는 프로그램

![](D:\GITHUB\lymchgmk.github.io\assets\img\posts\CS50\2-1.png)

- source code -> `compiler` -> machine code(0과 1로만 이루어진 코드)
  - 터미널에서 `clang hello.c`로 c 소스코드를 컴파일, `a.out`파일을 생성
    - `./a.out`으로 결과 확인
  - `clang -o hello hello.c`로 생성파일의 이름 지정 옵션 가능.
  - 파일 위에 붙는`*`는 머신코드임을 의미

- `ls`: 현 디렉토리의 파일들 조회
- `rm [파일이름]`: 파일 삭제
- `rmdir`: 디렉토리 삭제



- 한글 윈도우에서는 백슬래시 `\`가 원화표기 `₩`로 보임.



#### *생각해보기*

- *Q) 아래의 실습하기로 "hello, boostcourse를 출력해보세요."*

  - *A)*

    ```c
    #include <stdio.h>
    
    int main(void)
    {
    	printf("hello, boostcourse\n");
    }
    ```





### 2) 문자열

> C언어로 문자열 형식을 가진 변수를 선언하고 출력



```c
#include <cs50.h>
#include <stdin.h>

int main(void)
{
	string answer = get_string("What's your name?\n");
	printf("hello, %s\n", answer);
}
```

- `clang -o string string.c -lcs50`
  - `-o [파일 이름]`: 머신코드 저장 명령어
  - `-l[라이브러리 이름]`: "link"를 의미하는 `-l`명령어를 이용해 cs50파일과 합침. 이를 통해 컴파일 시 cs50파일을 연결하도록 컴파일러에게 알려줌.
- `make string`: `string.c`파일을 알아서 컴파일 하도록 수행. 단, `.c`를 제외한 소스코드의 이름으로 실행시킬 것.



- `get_string`함수

  ```c
  string answer = get_string("What's your name?\n");
  ```

  - 변수를 선언할 때, 데이터 타입을 지정해줘야함.
  - `=`: 할당 연산자
  - `\n`: 개행문자

- `printf`함수

  ```c
  printf(hello, %s\n", answer);
  ```

  - `%s`: 문자열 형식 지정자(placeholder)



#### *생각해보기*

- *Q) "좋아하는 동물을 알려주세요"로 질문하여 동물 이름을 animal이라는 변수에 저장하고, 이를 "내가 좋아하는 동물은"으로 출력해주는 코드를 작성해보세요.*

  - *A)*

    ```c
    #include <stdio.h>
    #include <cs50.h>
    
    int main(void)
    {
        string animal = get_string("좋아하는 동물을 알려주세요.\n");
        printf("내가 좋아하는 동물은 %s입니다.\n", animal);
    }
    ```





### 3) 조건문과 루프

> 조건문과 루프를 C언어로 작성



#### 변수

- 변수 선언 및 증가

```c
int counter = 0;
counter = counter + 1;
counter += 1;
counter++;
```



#### 조건문

- 조건문 `if`

```c
if (x < y)
{
	printf("x is less than y\n");
}
else if (x > y)
{
	printf("x is greater than y\n");
}
else
{
	printf("x is equal to y\n");
}
```



#### 루프

- 루프 `while`

```c
int i = 0;
while (i < 50)
{
	printf("hello, world!\n");
	i = i + 1;
}
```



- 루프 `for`

```c
for (int i = 0; i < 50; i = i + 1)
{
	printf("hello, world!\n");
}
```



#### *생각해보기*

- *Q) 학습한 다양한 방법을 이용하여 "개발공부는 재미있다!를 10번 출력하는 코드를 작성해보세요."*

  - *A)*

    ```c
    #include <stdio.h>
    
    int main(void)
    {
    	for (int i=0; i<10; i++)
    	{
    		printf("개발공부는 재미있다!\n");
    	}
    }
    ```





### 4) 자료형, 형식 지정자, 연산자

> 다양한 데이터 타입과 형식 지정자 및 연산자를 이용한 조건문 표현



#### 데이터 타입

- 자료형
  - `bool` / `int`, `long` / `float`, `double` / `char`, `string` 
    - `int`는 대략 40억까지 가능하므로, 일부 거대 기업을 제외하고는 대부분 정수에 `int`를 사용.
- 형식 지정자
  - `%c: char`
  - `%f: float, double`
  - `%i: int`
  - `%li: long`
  - `%s`: string

- 연산자



#### CS50 라이브러리 내의 get 함수

> get_char, get_double, get_float, get_int, get_long, get_string

```c
# include <cs50.h>
# include <stdio.h>

int main(void)
{
    int age = get_int("what's your age?\n");
    printf("Your are at least %i days old.\n", age * 365);
}
```



#### 형식 지정자

> 각 데이터 타입을 위한 형식 지정자

- **%c** : char
- **%f** : float, double
- **%i** : int
- **%li** : long
- **%s** : string



#### 기타 연산자 및 주석

- +: 더하기
- -: 빼기
- *: 곱하기
- /: 나누기
- %: 나머지
- &&: 그리고
- ||: 또는
- //: 주석



#### 정수와 실수를 받아서 출력해보기

> %i, %f 형식 지정자를 사용



#### 짝수인지 홀수인지 알려주는 코드짜기

> 2로 나누어 나머지가 0이냐 1이냐로 판별



#### 주석

> C에서`//`를 사용한 주석



##### 참고) #include <cs50.h> 는 무엇인가요?

> CS50 수업을 위한 라이브러리

- 라이브러리: 여러 함수들을 모아둔 것
- 표준 라이브러리
  - `#include <stdio.h>`
  - 가장 많이 쓰고 가장 보편적으로 사용하는 라이브러리를 기본적으로 설치해놓음



#### *생각해보기*

- *Q) 짝수인지 홀수인지 알려주는 코드짜기에 자신의 스타일 대로 주석을 달아보고 다른 수강생은 어떠헥 주석을 달았는지 비교해보세요.*

  - *A)*

    ```c
    #include <cd50.h>
    #include <stdio.h>
    
    int main()
    {
    	// 변수 n 입력
    	int n = get_int("n: ");
    	
    	// 짝수인 경우
    	if (n%2==0)
    	{
    		printf("n is even");
    	}
    	// 홀수인 경우
    	else
    	{
    		printf("n is odd");
    	}
    }
    ```





### 5) 사용자 정의 함수, 중첩 루프

> 프로그램을 간결하게 하는 사용자 정의 함수의 사용



#### 사용자 정의 함수

> 동일한 작업을 반복

- 독립적인 기능은 사용자 정의 함수로 만들어서 사용
  - 그래야 `main`함수가 아래로 내려가지 않고 보기 좋음.

```c
#include <stdio.h>

void cough(int n);

int main(void)
{
    cough(3);
}

void cough(int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("cough\n");
    }
}
```

- c언어는 오래되어 아래에 `cough`함수를 두면 에러가 발생.
  - 위에서 `cough`함수를 선언하고, `main`함수 아래에 `cough`함수를 구현하는 방식으로 작성
  - 선언부의 `int n`변수는 쓰레기 값(Garbage Value)를 가지고 있으니, 나중에 다시 제대로 넣어야 함.



#### 중첩 루프

> 여러 데이터를 가로나 세로로 반복하는 경우



#### *생각해보기*

- *Q) 사용자 정의 함수를 사용하는 것의 장점은 무엇일까요?*
  - *A) 반복되는 코드의 제거, 재사용 가능, 가독성 향상, 디버깅에 유리, 객체 지향적인 프로그래밍 가능*





### 6) 하드웨어의 한계

> 메모리 용량이 프로그램의 구동에 미치는 영향

- RAM은 **유한한 크기**의 비트만 저장할 수 있기 때문에 때때로 부정확한 결과를 내기도 함.



#### 부동 소수점 부정확성

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // 사용자에게 x 값 받기
    float x = get_float("x: ");

    // 사용자에게 y 값 받기
    float y = get_float("y: ");

    // 나눗셈 후 출력
    printf("x / y = %.50f\n", x / y);
}
```

```
// output
x: 1
y: 10
x / y = 0.10000000149011611938476562500000000000000000000000
```

- `float`에서 저장 가능한 비트 수가 유한하기 때문에 0.1이 아닌 다소 부정확한 결과를 냄



#### 정수 오버플로우

```c
#include <stdio.h>
#include <unistd.h>

int main(void)
{
    for (int i = 1; ; i *= 2)
    {
        printf("%i\n", i);
        sleep(1);
    }
```

```
// output
...
1073741824
overflow.c:6:25: runtime error: signed integer overflow: 1073741824 * 2 cannot be represented in type 'int'
-2147483648
0
0
...
```

- `int`는 32개의 비트만 가짐. 10억을 넘기자 앞으로 넘어갈 1의 자리가 없어져 그 이상의 숫자는 저장 불가.
  - "Y2K 문제"
  - 보잉 787에서 구동 후 248일이 지나면 모든 전력을 잃고 강제로 안전 모드로 진입하던 문제
    - 248일을 1/100초로 계산하면 대략 2^32였기 때문.
- 다루고자 하는 데이터 값의 범위를 유의하며 프로그램을 작성해야 한다.



#### *생각해보기*

- *Q) Y2K와 보잉787과 같은 문제를 방지하기 위해서는 프로그램을 어떻게 설계해야 할까요?*
  - *A)*
    - 1. *입력값의 크기에 맞는 넉넉한 자료형으로 변수 선언*
      2. *프로그래밍 실행 전 오버플로우 테스트*
      3. *오버플로우 예외처리*
      4. *오버플로우 발생시 초기화 실행*







## 3. 배열

### 1) 컴파일링

> 컴파일링의 4 단계, 전처리 / 컴파일링 / 어셈블링 / 링킹

- `main`함수: 프로그램의 시작점으로, 실행 버튼을 클릭하는 것과 같음
- `printf`함수: 출력을 담당하는 함수
  - `stdio.h`라이브러리: 헤더 파일. C언어로 작성되어 있으며 파일명이 `.h`로 끝남.



#### 전처리(Precompile)

> 컴파일 전, #include 실행

- 전처리기에 의해 수행.
  - 실질적인 컴파일 전에 무언가를 실행하라는 명령
- `#`으로 시작되는 C 소스 코드.
  - `#include`: 전처리기에 다른 파일의 내용을 포함하도록 명령
    - 전처리기는 새로운 파일(여전히 C 소스 코드)을 생성



#### 컴파일(Compile)

> 컴파일러가 C 소스 코드를 어셈블리 코드로 컴파일

- 컴퓨터가 이해할 수 있는 언어와 최대한 가까운 프로그램으로 만듦

- 소스코드에서 오브젝트 코드로 변환하는 전체 과정을 통틀어 의미하기도 하지만, 구체적으로 소스 코드를 어셈블리 코드로 변환하는 단계를 의미하기도 함.



#### 어셈블(Assemble)

> 어셈블러가 어셈플리 코드를 오브젝트 코드로 변환

- 연속된 0과 1들로 바꿔주는 작업
- 컴파일 해야하는 파일이 딱 한 개라면 여기서 끝나지만, 여러 개라면 링크라고 하는 단계가 추가됨.



#### 링크(Link)

>  여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합치는 단계.

- 추가적인 단계



#### *생각해보기*

- *Q) 만약 컴파일링 과정을 거치지 않기 위해 바로 머신코드로 우리가 원하는 프로그램을 작성하려고 한다면 어떤 문제가 있을까요?*
  - *A)*
    - 1. *가독성 난해로 인한 작업 능률 감소 및 디버깅 난이도 상승*
      2. *컴파일을 할 수 없으므로 프로그램 산출물에 대한 평가가 불가능*





### 2) 디버깅

> 코드에 있는 버그를 식별하고 고치는 과정



#### 버그와 디버깅

- `버그(Bug)`: 코드에 들어있는 오류
  - 실제 벌레에서 기원



#### 디버깅의 기본

- 프로그램을 한 행씩 실행하며 특정 행에서 멈추게 하고 (중지점) 단계별로 확인



##### help50

> CS50 IDE에서 컴파일시 생기는 오류를 해석해줌

```c
help50 make 파일이름
```



##### printf

- 직접 의심이 가는 변수를 출력해서 확인



##### debug50

> CS50 IDE에서 브레이크 포인트를 지정하고 소스파일을 컴파일 후 `debug50 파일이름`으로 디버깅 패널 사용



#### *생각해보기*

- *Q) 디버깅을 도와주는 프로그램은 어떤 경우에 더 큰 도움이 될까요? 만약 이런 프로그램의 도움 없이 직접 디버깅을 해야 한다면 어떻게 코드를 작성하는 것이 좋을까요?*
  - *A)*
    - *코드가 길고 복잡한 경우 디버깅을 도와주는 프로그램이 크게 도움이 됨. 버그의 이유, 버그의 종류 등을 확인하기 쉬움.*
    - *만약 디버깅 툴을 사용할 수 없다면, 기능별로 가능한 만큼 코드를 함수형으로 작성한 뒤, 출력을 이용해서 디버깅을 해야함.*





### 3) 코드의 디자인

> 코드의 정확성과 디자인을 관리하는 방법



##### check50

> CS50 IDE에서 과제 수행 확인 용 자동 검사 프로그램



##### style50

> CS50 IDE에서 코드의 심미성 검사, 스타일 가이드 확인



#### 고무 오리

> 내가 작성한 코드를 한 줄 씩 고무 오리같은 물체에게 설명해주며 스스로 디버깅





#### *생각해보기*

- *Q) 만약 여러 사람들이 함께 참여하는 프로젝트에서, 각자가 작성하는 코드 스타일이 서로 다르다면 어떤 비효율적인 일이 발생할까요?*
  - *A)*
    - *여러 코딩 컨벤션이 섞이면, 코드의 가독성이 떨어진다.*
    - *특히 들여쓰기의 space가 몇 칸인지, tab을 사용하는지에 따라 언어에 따라서는 오류가 발생하기도 하며, 이런 오류는 직접 찾기 매우 어렵다.*





### 4) 배열(1)

> 배열을 정의하고 사용하는 방법



#### 메모리

> 각각의 자료형은 서로 다른 크기의 메모리를 차지

- `bool: 1바이트`
- `char: 1바이트`
- `int: 4바이트`
- `float: 4바이트`
- `long: 8바이트`
- `double: 8바이트`
- `string: ?바이트`



#### 배열

> 같은 자료형의 데이터를 메모리에 연속적으로 저장하고, 이를 하나의 변수로 관리



#### *생각해보기*

- *Q) 실생활의 어떤 데이터를 배열로 표현할 수 있을까요?*
  - *A)*
    - *날씨, 시험 점수 등 속성이 명확하고 계량이 가능한 데이터*





### 5) 배열(2)

> 배열과 전역 변수



#### 전역 변수

> 코드 전반에 거쳐 바뀌지 않는 값

- `const int N = 3;`
  - 전역 변수의 이름은 대문자로 표기



#### 배열의 동적 선언 및 저장

- 배열의 크기를 사용자에게 입력 받고, 루프를 돌면서 인덱스를 이용해 입력 받은 값을 저장



#### *생각해보기*

- *Q) 점수의 평균을 구하는 예제에서, 동적으로 작성한 코드는 그렇지 않은 코드에 비해 어떤 장단점이 있을까요?*
  - *A)*
    - *동적으로 작성한 코드는 변수가 입력에 따라 자동으로 변하지만, 그렇지 않은 코드는 직접 변수에 값을 할당해줘야 한다.*
    - *높은 재사용성과 코드의 유연성*





### 6) 문자열과 배열

> 문자열이 C에서 정의되는 방식과 메모리에 저장되는 방식



- `string` 자료형은 사실 `char`자료형의 배열로 정의 됨.
  - 인덱스로 각 문자에 접근 가능



- 널 종단 문자
  - `ASCII`에서 0의 값을 가짐



#### *생각해보기*

- *Q) 널 종단 문자는 왜 필요할까요?*
  - *A)*
    - *문자열이 끝나는 위치를 추적, 문자열의 길이를 계산하는데 사용*
    - *널 종단 문자가 없는 경우, 메모리에 있는 문자열이 다음 메모리 데이터 블록을 침범할 수 있음*





### 7) 문자열의 활용

> 문자열을 탐색하고 일부 문자를 수정



#### 문자열의 길이 및 탐색

- 문자열의 끝은, 해당 인덱스의 문자가 널 종단 문자(`\0`)과 일치하는지 검사하면 알 수 있다.
  - 혹은, `string.h` 라이브러리의 `strlen()` 함수를 사용

```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string s = get_string("Input: ");
    printf("Output:\n");
    for (int i = 0, n = strlen(s); i < n; i++)
    {
        printf("%c\n", s[i]);
    }
}
```



#### 문자열 탐색 및 수정

- `ASCII`값으로 영문자 소문자는 대문자보다 32씩 큼
  - `ctype.h`라이브러리의 `toupper()` 함수





####  *생각해보기*

- *Q) string.h와 ctype.h의 라이브러리에 다른 어떤 함수가 있는지 확인해 보고, 어떤 함수를 어떻게 활용해 볼 수 있을지 생각해봅시다.*
  - *A)*
    - *문자열이 끝나는 위치를 추적, 문자열의 길이를 계산하는데 사용*
    - *널 종단 문자가 없는 경우, 메모리에 있는 문자열이 다음 메모리 데이터 블록을 침범할 수 있음*





### 8) 명령행 인자

> `make`나 `clang`같은 명령에, 옵션을 추가할 수 있음.

- `main`함수에 `int argc`, `string argv[]`를 변수로 입력 받을 수 있음
  - `argc`: 입력의 개수
  - `argv[]`: 입력이 포함된 배열
    - `argv[0]`는 기본적으로 프로그램의 이름



#### *생각해보기*

- *Q) 명령행 인자는 프로그램의 확장성에 어떤 도움이 될까요? 구체적인 예시를 떠올려보세요.*
  - *A)*
    - *사용자나 다른 프로그램에 입력 데이터를 전달할 수 있다.*
      - *만약, 전달되지 않는 경우 이를 감지하고 사용자에게 입력을 요청하도록 하여 확정성에 도움이 된다.*







## 4. 알고리즘



### 1) 검색 알고리즘

> 주어진 배열에서 특정 값을 찾기



#### 선형 검색

> 인덱스를 처음부터 끝까지 하나씩 증가시키며 검사



#### 이진 검색

> 배열이 정렬되어 있는 경우, 찾고자 하는 값과 남은 배열의 중간 값을 비교하며 이동



#### *생각해보기*

- *Q) 만약 정렬되지 않은 배열이 있다면, 선형 검색이 빠를까요 이진 검색이 빠를까요?*
  - *A)*
    - *정렬하지 않고 검색을 한다면 이진 검색은 불가능하고 선형 검색만 사용가능하며, 정렬 후 검색한다면 충분히 배열이 크다는 전제하에 이진 검색이 빠르다.*





### 2) 알고리즘 표기법

> 알고리즘 실행 시간의 상한과 하한



- **Big O** 표기법: 알고리즘 실행 시간의 **상한**
  - O는 "on the order of"의 약자
- **Big  Ω** 표기법: 알고리즘 실행 시간의 **하한**



#### *생각해보기*

- *Q) 실행시간의 상한이 낮은 알고리즘이 더 좋을까요, 하한이 낮은 알고리즘이 더 좋을까요?*
  - *A)*
    - *경우에 따라 다르지만 일반적으로는 최악의 경우를 상정하기 때문에, 상한이 낮은 알고리즘을 선호한다.*





### 3) 선형 검색

> 주어진 배열 또는 구조체에서 선형 검색



#### 선형 검색

> 원하는 원소가 발견될 때까지 처음부터 마지막 자료까지 차례대로 검색



#### 효율성 그리고 비효율성

- 선형 검색 알고리즘은 정확하지만 비효율적
  - 자료가 정렬되어 있지 않거나, 그 어떤 정보도 없는 경우 유용

- **구조체**를 정의해서 더 확장성있고 효율적인 검색 프로그램 가능
  - 예를 들어, 전화번호부에 이름과 번호를 묶어서 구조체로 정의



#### *생각해보기*

- *Q) 전화번호부와 같이 구조체를 정의하여 관리 및 검색을 하면 더 편리한 예는 또 무엇이 있을까요?*
  - *A)*
    - *사용자의 회원 정보와 같이, 여러 관련있는 속성을 한꺼번에 관리해야 하는 경우에 구조체가 유리하다.*





### 4) 버블 정렬

> 버블 정렬의 원리와 실행 시간 및 구현



#### 버블 정렬

> 두 개의 인접한 자료 값을 비교하면서 위치를 교환

- 인접한 두 수를 계속 비교하는 것을 n번 수행

- **O(n^2)**
- **Ω(n^2)**



#### *생각해보기*

- *Q) 버블 정렬이 효율적인 경우는 어떤 경우인가요? 반대로 어떤 경우에 비효율적이게 될까요?*
  - *A)*
    - *배열의 메모리가 클 때, 버블 정렬은 제자리에 데이터를 교환하므로 메모리 누수가 거의 없는 장점이 있다.*
    - *최선이든 최악이든 O(n^2)의 시간복잡도를 가지므로, 배열이 클 수록 비효율적이며, 데이터가 역순으로 정렬되어 있을 경우 가장 교환 횟수가 많다.*





### 5) 선택 정렬

> 선택 정렬의 원리와 실행 시간 및 구현



#### 선택 정렬

> 배열 안의 자료 중 가장 작은(혹은 가장 큰) 수를 찾아 첫 번째 위치(혹은 마지막 위치)와 교환

- 자리를 처음부터 마지막까지 따라가며, 그 자리에 맞는 작은 수를 배열에서 찾아오는 방식

- **O(n^2)**
- **Ω(n^2)**



#### *생각해보기*

- *Q) 선택정렬을 좀 더 효율적으로 어떻게 바꿀 수 있을까요?*
  - *A)*
    - 1. *이중 선택 정렬: 한 번의 탐색에서 최솟값과 최댓값을 같이 찾는 방법. 탐색 횟수를 절반으로 줄일 수 있다.*
      2. *탐색을 응용하여 개선: 한 번의 탐색 때 동일한 값이 있다면 함께 정렬하는 방법. 같은 값이 많을수록 유리.*





### 6) 정렬 알고리즘의 실행시간

> 여러 정렬 알고리즘과 검색 알고리즘의 실행 시간을 Big O와 Big Ω로 정의



#### 실행시간의 상한

- **O(n^2)**: 선택 정렬, 버블 정렬
- **O(n log n)**
- **O(n)**: 선형 검색
- **O(log n)**: 이진 검색
- **O(1)**



#### 실행시간의 하한

- **Ω(n^2)**: 선택 정렬, (일반적인 상황의) 버블 정렬
- **Ω(n log n)**
- **Ω(n)**: (교환이 일어나지 않는 경우의) 버블 정렬
- **Ω(log n)**
- **Ω(1)**: 선형 검색, 이진 검색



#### *생각해보기*

- *Q) 선택 정렬의 실행 시간의 하한도 버블 정렬처럼 더 단축시킬 수 있을까요?*
  - *A)*
    - *교환이 이루어지지 않아도 배열 전체를 계속 탐색하기 때문에 불가능.*





### 7) 재귀

> 함수를 재귀적으로 사용하는 코드를 작성



#### 재귀

> 함수가 본인 스스로를 호출해서 사용



#### *생각해보기*

- *Q) 반복문을 쓸 수 있는데도 재귀를 사용하는 이유는 무엇일까요?*
  - *A)*
    - *변수를 여럿 만들 필요가 없고, 코드가 간결해짐*
    - *프로그램 작성 시 직관적인 이해에 도움이 됨*





### 8) 병합 정렬

> 재귀를 활용한 병합 정렬 구현



#### 병합 정렬

> 원소가 한 개가 될 때까지 계속해서 반으로 나누고, 다시 합쳐가며 정렬

- **O(n log n)**
-  **Ω(n log n)**



#### *생각해보기*

- *Q) 병합 정렬을 선택 정렬이나 버블 정렬과 비교했을 때 장점과 단점은 무엇이 있을까요?*
  - *A)*
    - *장점*
      - *선택 정렬은 불안정 정렬이지만, 병합 정렬은 안정 정렬*
      - *O(log n)의 시간복잡도*
      - *연결 리스트로 구성하면, 링크 인덱스만 변경되므로 차지하는 메모리를 크게 줄일 수 있다.*
    - *단점*
      - *배열로 구성된 경우, 분할한 배열로 인한 높은 메모리 차지*







## 5. 메모리

### 1) 메모리 주소

> C언어로 메모리 주소에 접근하고 값을 받아오는 코드를 작성하기



#### 16진수

> 컴퓨터과학에서는 숫자를 주로 16진수로 표현



#### 10진수를 16진수로 바꾸어보기

> "0x"를 붙여서 16진수임을 표기함

![16진수](D:\GITHUB\lymchgmk.github.io\assets\img\posts\CS50\5-1.png)



#### 16진수의 유용성

> 2개의 16진수는 1byte의 2진수로 변환이 가능

- 2진수는 컴퓨터의 메모리에 대해 직접적인 이해가 가능하지만, 숫자를 길게 적어야 함.
  - 이를 축약하기 위해 16진수를 사용
    - 16진법은 한 자릿수가 4비트를 의미하기 때문에 유용
      - 16진법 두 자리 = 1바이트 2진수



#### 메모리 주소

> C에서는 변수의 메모리 주소를 받기 위해 `&` 연산자를, 메모리 주소를 점유하는 실제 값을 얻기위해 `*`연산자를 사용

```c
#include <stdio.h>

int main(void)
{
	int n = 50;
	printf("%p\n", &n); // 변수 n의 메모리 주소
	printf("%i\n", *&n); //변수 n의 정수값인 50
}
```

- `%p`: 포인터 변수의 주소를 16진수로 출력



#### *생각해보기*

- *Q) 'CS50'을 16진수로 표현해볼까요?*
  - *A) ASCII코드에서 각각 10진수로 67, 83, 53, 48이므로, 16진수로 변환하면 43, 53, 35, 30이므로, 0x43533530으로 표기 가능*





### 2) 포인터

> 포인터 변수를 정의하고 사용

- `*`연산자를 이용해서 포인터 역할을 하는 변수를 선언할 수 있음.

```c
#include <stdio.h>

int main(void)
{
	int n = 50;
	int *p = &n;
	printf("%p\n", p); // 포인터 p가 가리키는 변수 n의 주소값 출력
	printf("%i\n", *p); // 포인터 p가 가리키는 변수 n의 값 출력
}
```



#### *생각해보기*

- *Q) 포인터의 크기는 메모리의 크기와 어떤 관계가 있을까요?*
  - *A) 포인터 변수는 자료형에 상관없이 메모리 크기가 언제나 동일*
    - *32비트 CPU에서는 1word의 크기가 4byte이므로, 포인터 변수의 크기는 4byte*
    - *64비트 CPU에서는 1word의 크기가 8byte이므로, 포인터 변수의 크기는 8byte*
      - *1word는 CPU가 처리할 수 있는 메모리의 기본 단위를 의미*





### 3) 문자열

> 문자열 형태의 string 자료형의 정의에 대해

![문자열](D:\GITHUB\lymchgmk.github.io\assets\img\posts\CS50\5-3.png)

- 문자열은 문자 배열
  - 가장 마지막은 `\0`로, 문자열의 끝을 표시
  - **포인터**로 구현되어 있음

```c
#include <stdio.h>

int main(void)
{
	char *s = "EMMA";
	printf("%s\n", s);
}
```





#### *생각해보기*

- *Q) string 자료형을 정의해서 사용하면 어떤 장점이 있을까요?*
  - *A)*
    - *추상화, 가독성 향상*
    - *특정 데이터 유형을 강제할 수 있다.*
    - *메서드 구현*





### 4) 문자열 비교

> 문자열이 저장되어 있는 방식을 통한 문자열 비교



- 문자열의 문자는 메모리에 연속적으로 저장되어 있다.
  - 주소값을 하나씩 증가시기면 다음 문자의 값을 조회할 수 있음.
    - 두 개의 문자열이 저장된 변수를 직접 비교하면, ***주소가 다르기 때문에***  다르다는 결과가 나옴.



#### *생각해보기*

- *Q) 문자열을 비교하는 코드는 어떻게 작성해야 할까요?*
  - *A) 주소가 아닌, 실제 값을 비교하면 된다.*





### 5) 문자열 복사

> 문자열을 복사하는 방법



- `string s`는 `char *s`와 동일한 의미.
  - 문자열 값이 아닌 문자열의 메모리 주소를 저장.
  - 동일한 주소를 가리킨다면, 변경시 함께 변경됨.

- 따라서, 복사하려면 **메모리 할당 함수, `malloc`**을 사용해야 함.
  - 단, 문자열의 길이에 `\0`의 +1한 메모리를 할당해야 함.

```c
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    char *s = get_string("s: ");
    char *t = malloc(strlen(s) + 1);

    for (int i = 0, n = strlen(s); i < n + 1; i++)
    {
        t[i] = s[i];
    }

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
```



#### *생각해보기*

- *Q) 배운 바와 같이 메모리 할당을 통해 문자열을 복사하지 않고, 단순히 문자열의 주소만 복사했을 때는 어떤 문제가 생길까요?*
  - *A) 복사된 문자열을 변경 시 원하지 않는 원본 문자열도 함께 변경이 된다.*





### 6) 메모리 할당과 해제

> 메모리를 할당하고 해제해보기



- `free`: 메모리를 해제해주는 함수
  - 메모리를 해제해주지 않으면 메모리에 **쓰레기 값**이 남아 있고, 메모리 용량의 낭비가 발생.
    - 이를 **메모리 누수**라고 함



- **버퍼 오버플로우**: 준비된 버퍼보다 더 많은 양의 데이터를 입력하는 경우 발생
  - 정의되지 않은 인덱스에 접근하는 경우 발생
  - 해커가 메모리(주로 스택)의 값을 변조할 때도 사용



#### *생각해보기*

- *Q) 제한된 메모리를 가지고 프로그래밍을 할 때 메모리를 해제하지 않으면 어떤 문제가 발생할 수 있을까요?*
  - *A) 메모리 누수로 인해 작동 메모리가 부족, 다른 프로그램이 조기 종료되거나 시스템의 작동이 멈출 수 있다.*





### 7) 메모리 교환, 스택, 힙

> 메모리에 저장된 두 값을 교환하는 코드를 작성



```c
#include <stdio.h>

void swap(int a, int b);

int main(void)
{
    int x = 1;
    int y = 2;
    
    printf("x is %i, y is %i\n", x, y);
    swap(x, y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```

- 이렇게 `swap`함수를 구현하면 a, b는 각각 x, y의 값을 복제하여 다른 메모리 주소에 저장.
  - x, y의 값은 변화하지 않음
    - 이를 해결하기 위해 **포인터**를 이용해서 `swap`을 구현해야 함.

```c
#include <stdio.h>

void swap(int *a, int *b);

int main(void)
{
    int x = 1;
    int y = 2;
    
    printf("x is %i, y is %i\n", x, y);
    swap(&x, &y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```



![메모리 영역](D:\GITHUB\lymchgmk.github.io\assets\img\posts\CS50\5-7.png)

- 메모리 안에는 데이터가 저장되는 구역이 나누어져 있음
  - 머신 코드 영역에는 프로그램이 컴파일된 바이너리가 저장
  - 글로벌 영역에는 프로그램의 전역 변수가 저장
  - 힙 영역에는 `malloc`으로 할당된 메모리의 데이터가 저장
  - 스택 영역에는 프로그램 내 함수 관련 데이터가 저장

- 위 `swap`코드에서, x, y, a, b, tmp 변수는 모두 스택 영역에 저장
  - 하지만, 서로 다른 주소에 저장됨
    - 따라서 포인저로 지정해줘야 변경이 됨



#### *생각해보기*

- *Q) 메모리 영역을 다양하게 나누느 이유는 무엇일까요?*
  - *A) 유사한 성향의 데이터를 묶어서 저장하면 관리가 용이하고 접근속도가 향상되기 때문 (신뢰성 및 보안성 상승)*
    - *각각의 변수, 함수, 클래스가 호출되고 해제되는 시기가 다르기 때문에 메모리 낭비를 줄일 수 있다.*





### 8) 파일 쓰기

> 사용자로부터 값을 입력받아 파일을 출력

- 힙 영역에서는 `mallo`에 의해 메모리가 더 할당될 수록, 점점 사용하는 메모리의 범위가 아래로 증가
- 스택 영역에서는 함수가 더 많이 호출될 수록 점점 사용하는 메모리의 범위가 위로 증가.
  - 점점 늘어나다 보면 제한된 메모리 용량 하에서는, 서로의 침범이 발생할 수 있음.
    - 이를 각각 **힙 오버플로우**, **스택 오버플로우**라고 함



#### 사용자에게 입력 받기

- `scanf`함수: 사용자로부터 형식 지정자에 해당하는 값을 입력받아 저장.



#### 파일 쓰기

- `fopen`함수: 파일을 `FILE`이라는 자료형으로 불러오는 함수
- `fprintf`함수: `printf`함수 처럼 파일 내용을 직접 출력
- `fclose`함수: 파일에 대한 작업 종료



#### *생각해보기*

- *Q) get_long, get_float, get_char도 비슷한 방식으로 직접 구현할 수 있을까요?*
  - *A) `scanf`함수와 형식 지정자, 포인터를 사용하면 구현 가능*





### 9) 파일 읽기

> 파일을 읽고 JPEG 파일인지를 검사하는 프로그램 작성

```c
#include <stdio.h>

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        return 1;
    }

    FILE *file = fopen(argv[1], "r");

    if (file == NULL)
    {
        return 1;
    }
 
    unsigned char bytes[3];
    fread(bytes, 3, 1, file);

    if (bytes[0] == 0xff && bytes[1] == 0xd8 && bytes[2] == 0xff)
    {
        printf("Maybe\n");
    }
    else
    {
        printf("No\n");
    }
    fclose(file);
}
```

- 파일의 이름을 입력으로 받음
  - `argc`가 2가 아니라면, 파일명이 없거나 다른 인자가 입력된 경우이므로 오류(1) 리턴 후 종료
  - `argc`가 2라면, 파일명(`argv[1]`)을 읽기(`r`)모드로 불러옴
    - 파일이 제대로 열리지 않으면 `fopen`함수에서 `NULL`리턴
    - 파일이 제대로 열렸다면, `fread`함수를 사용해서 파일에서 첫 3바이트를 읽음.
      - 읽은 첫 3바이트가 `0xFF, 0xD8, 0xFF`인지를 확인. 이는 JPEG 형식의 시작점에 꼭 포함되어야 하는 데이터.





#### *생각해보기*

- *Q) JPEG 외에 다른 파일 형식도 그 형식임을 알려주는 약속이 있을까요?*
  - *A)이를 **파일 시그니처** 혹은 **파일 매직 넘버**라고 함.*
    - [List of file signatures](https://en.wikipedia.org/wiki/List_of_file_signatures)
    - 이를 이용해서 손상된 파일을 복구하거나, 파일의 손상 여부를 확인하거나, 숨겨진 내용을 파악하는데 사용함.
    - 파일의 처음에만 존재하는 파일 포맷도 있고, 처음과 마지막에 존재하는 파일 포맷도 있음.
      - 이를 각각 **헤더 시그니처**, **푸터 시그니처**라고 함.







## 6. 자료구조

### 1) malloc과 포인터 복습

> malloc 함수의 용법과 포인터의 개념

- `malloc` 함수를 사용해서 메모리를 할당하지 않으면, 초기화 되지 않은 변수는 임의의 주소를 가지고 있고, 오류를 발생시킬 수 있는 문제가 있음



#### *생각해보기*

- *Q) 포인터를 초기화시키지 않고 값을 저장하면 어떤 오류가 발생할 수 있을까요?*
  - *A) 임의의 주소에 값을 저장하게 되므로, 값이 중복되거나 엉뚱한 곳에 저장되는 오류가 발생함.*
    - *특히 엑세스 권한이 없는 메모리를 가리킬 수 있으며, 이 경우 분할 오류가 발생하고 프로그램이 중단될 수 있음.*





### 2) 배열의 크기 조정하기

> 배열의 크기를 조정하는 코드 작성



- 일정한 크기의 배열이 주어졌을 때, 그 크기를 키우려면?
  - 새로운 공간에 큰 메모리를 할당하고 기존 배열의 값을 옮겨줘야함
    - **O(n)**

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    //int 자료형 3개로 이루어진 list 라는 포인터를 선언하고 메모리 할당
    int *list = malloc(3 * sizeof(int));

    // 포인터가 잘 선언되었는지 확인
    if (list == NULL)
    {
        return 1;
    }

    // list 배열의 각 인덱스에 값 저장
    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    //int 자료형 4개 크기의 tmp 라는 포인터를 선언하고 메모리 할당
    int *tmp = malloc(4 * sizeof(int));

    if (tmp == NULL)
    {
        return 1;
    }

    // list의 값을 tmp로 복사
    for (int i = 0; i < 3; i++)
    {
        tmp[i] = list[i];
    }

    // tmp배열의 네 번째 값도 저장
    tmp[3] = 4;

    // list의 메모리를 초기화
    free(list);

    // list가 tmp와 같은 곳을 가리키도록 지정
    list = tmp;

    // 새로운 배열 list의 값 확인
    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    // list의 메모리 초기화
    free(list);
}
```

- 이 과정을 `relloc`함수로 대체 가능

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int *list = malloc(3 * sizeof(int));
    if (list == NULL)
    {
        return 1;
    }

    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    // tmp 포인터에 메모리를 할당하고 list의 값 복사
    int *tmp = realloc(list, 4 * sizeof(int));
    if (tmp == NULL)
    {
        return 1;
    }

    // list가 tmp와 같은 곳을 가리키도록 지정
    list = tmp;

    // 새로운 list의 네 번째 값 저장
    list[3] = 4;

    // list의 값 확인
    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    //list 의 메모리 초기화
    free(list);
}
```



#### *생각해보기*

- *Q)이미 할당된 메모리의 크기를 조절할 때 임시 메모리를 새로 할당해줘야 하는 이유는 무엇인가요?*

  - *A)새로 할당할 데이터가 얼마나 많은 메모리를 차지할지 모르기 때문에, 힙에 임시 메모리 블록을 생성해서 동적으로 메모리를 관리해야 함*

    - *원본 데이터를 임시 메모리에 복사하지 않으면 원래 지정했던 값은 포인터값으로 대체되어 쓰레기 값이 저장되거나, 데이터를 덮어쓸 수 있음*






### 3) 연결리스트: 도입

> 연결리스트의 정의

![연결리스트](D:\GITHUB\lymchgmk.github.io\assets\img\posts\CS50\6-3.png)

- 데이터 구조: 컴퓨터 메모리를 더 효율적으로 관리하기 위해 새로 정의하는 구조체
- 연결 리스트: 각 값이 메모리 상의 여러 군데 나뉘어져 있어도, 메모리 주소만 알고 있으면 연결가능.
  - 자신의 값과 바로 다음 값의 주소를 저장하는 구조

```c
typedef struct node
{
    int number;
    struct node *next;
}
node;
```



#### *생각해보기*

- *Q)연결 리스트를 배열과 비교했을 때 장단점은 무엇이 있을까요?*
  - *A)*
    - *장점*
      - *배열과 달리 연속 메모리 위치에 있지 않아도 되므로, 메모리 사용 개선 가능.*
      - *주소로 바로 접근 가능하므로 삽입/삭제 빠름*
    - *단점*
      - *느린 검색*
      - *물리적으로 인접한 메모리에 데이터가 위치하지 않으므로 접근 시간이 배열보다 오래 걸림*
      - *참조 포인터를 위한 메모리 공간 소모*





### 4) 연결 리스트: 코딩

> 연결 리스트를 구현하고 사용

```c
#include <stdio.h>
#include <stdlib.h>

//연결 리스트의 기본 단위가 되는 node 구조체를 정의합니다.
typedef struct node
{
    //node 안에서 정수형 값이 저장되는 변수를 name으로 지정합니다.
    int number; 

    //다음 node의 주소를 가리키는 포인터를  *next로 지정합니다.
    struct node *next;
}
node;

int main(void)
{
    // list라는 이름의 node 포인터를 정의합니다. 연결 리스트의 가장 첫 번째 node를 가리킬 것입니다. 
    // 이 포인터는 현재 아무 것도 가리키고 있지 않기 때문에 NULL 로 초기화합니다.
    node *list = NULL;

    // 새로운 node를 위해 메모리를 할당하고 포인터 *n으로 가리킵니다.
    node *n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number 필드에 1의 값을 저장합니다. “n->number”는 “(*n).numer”와 동일한 의미입니다. 
    // 즉, n이 가리키는 node의 number 필드를 의미하는 것입니다. 
    // 간단하게 화살표 표시 ‘->’로 쓸 수 있습니다. n의 number의 값을 1로 저장합니다.
    n->number = 1;

    // n 다음에 정의된 node가 없으므로 NULL로 초기화합니다.
    n->next = NULL;

    // 이제 첫번째 node를 정의했기 떄문에 list 포인터를 n 포인터로 바꿔 줍니다.
    list = n;

    // 이제 list에 다른 node를 더 연결하기 위해 n에 새로운 메모리를 다시 할당합니다.
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number와 next의 값을 각각 저장합니다.
    n->number = 2;
    n->next = NULL;

    // list가 가리키는 것은 첫 번째 node입니다. 
    //이 node의 다음 node를 n 포인터로 지정합니다.
    list->next = n;

    // 다시 한 번 n 포인터에 새로운 메모리를 할당하고 number과 next의 값을 저장합니다.
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    n->number = 3;
    n->next = NULL;

    // 현재 list는 첫번째 node를 가리키고, 이는 두번째 node와 연결되어 있습니다. 
    // 따라서 세 번째 node를 더 연결하기 위해 첫 번째 node (list)의 
    // 다음 node(list->next)의 다음 node(list->next->next)를 n 포인터로 지정합니다.
    list->next->next = n;

    // 이제 list에 연결된 node를 처음부터 방문하면서 각 number 값을 출력합니다. 
    // 마지막 node의 next에는 NULL이 저장되어 있을 것이기 때문에 이 것이 for 루프의 종료 조건이 됩니다.
    for (node *tmp = list; tmp != NULL; tmp = tmp->next)
    {
        printf("%i\n", tmp->number);
    }

    // 메모리를 해제해주기 위해 list에 연결된 node들을 처음부터 방문하면서 free 해줍니다.
    while (list != NULL)
    {
        node *tmp = list->next;
        free(list);
        list = tmp;
    }
}
```



#### *생각해보기*

- *Q)연결 리스트의 중간에 node를 추가하거나 삭제하는 코드는 어떻게 작성할 수 있을까요?*
  - *A) 삽입 / 삭제를 원하는 위치의 이전노드와 이후노드의 포인터를 이용해 작성*





### 5) 연결 리스트: 시연

> 연결 리스트와 배열의 장단점

- 연결리스트
  - 장점
    - 새로운 값 추가에 다시 메모리 할당 필요없음
  - 단점
    - 임의 접근이 불가능
    - 값을 추가하거나 검색할 때 **O(n)**
      - 배열은 (정렬되어 있는 경우) 이진 검색을 이용하면 **O(log n)**



#### *생각해보기*

- *Q)배열이 정렬되어 있지 않은 경우의 검색 소요 시간을 연결 리스트의 검색 시간과 비교해보세요.*
  - *A) 이진 검색을 사용할 수 없으므로, 선형 탐색을 해야하므로 이는 마찬가지로 O(n)의 시간 복잡도를 가진다.*





### 6) 연결 리스트: 트리

> 트리의 구조를 설명하고 활용하는 코드 작성

```c
//이진 검색 트리의 노드 구조체
typedef struct node
{
    // 노드의 값
    int number;

    // 왼쪽 자식 노드
    struct node *left;
 
   // 오른쪽 자식 노드
    struct node *right;
} node;

// 이진 검색 함수 (*tree는 이진 검색 트리를 가리키는 포인터)
bool search(node *tree)
{
    // 트리가 비어있는 경우 ‘false’를 반환하고 함수 종료
    if (tree == NULL)
    {
        return false;
    }
    // 현재 노드의 값이 50보다 크면 왼쪽 노드 검색
    else if (50 < tree->number)
    {
        return search(tree->left);
    }
    // 현재 노드의 값이 50보다 작으면 오른쪽 노드 검색
    else if (50 > tree->number)
    {
        return search(tree->right);
    }
    // 위 모든 조건이 만족하지 않으면 노드의 값이 50이므로 ‘true’ 반환
    else {
        return true;
    }
}
```

- 이진 검색 트리
  - 검색: **O(log n)**
  - 삽입: **O(log n)**



#### *생각해보기*

- *Q)값을 검색할 때 이진 검색 트리가 기본 연결 리스트에 비해 가지는 장점과 단점은 무엇이 있을까요?*
  - *A)*
    - *장점*
      - *빠른 검색 / 삽입 속도*
    - *단점*
      - *최악의 경우, 한 쪽으로만 이루어진 트리에서 메모리 낭비가 심함*





### 7) 해시 테이블

> 해시 테이블의 원리와 구조

- 해시 테이블: "연결 리스트의 배열"
  - "해시 함수"를 이용해서 key 값을 생성하고, 그 key 값과 value값을 매칭시켜 저장.
  - **O(1)**



#### *생각해보기*

- *Q)해시 함수는 어떻게 만들 수 있을까요?*
  - *A)*
    - *대표적으로 나누기 / 곱하기를 이용해 만듦*
      - *나누기 방법: 원소를 해시 테이블의 크기로 나누고, 그 나머지 값을 주소로 사용*
      - *곱하기 방법: 원소를 0과 1사이의 소수로 대응시키고, 그 값에 해시 테이블의 크기를 곱한 값의 정수값을 주소로 사용.*
    - *MD5, SHA-1, SHA-256 / CRC32등이 있음*





### 8) 트라이

> 트라이의 원리와 구조

<img src="D:\GITHUB\lymchgmk.github.io\assets\img\posts\CS50\6-8.png" alt="트라이" style="zoom:150%;" />

- 트라이: 각 노드가 배열로 이루어진 트리

  - 주로 문자열에 적용하여 사용

  

#### *생각해보기*

- *Q)트라이가 해시 테이블에 비해 가지는 장점과 단점은 무엇일까요?*
  - *A)*
    - *장점*
      - *해시 테이블은 데이터가 편향적인 경우 매우 느려지지만, 트라이는 평균적으로 가장 빠름을 보장함*
    - *단점*
      - *아주 많은 메모리를 필요로 함*





### 9) 스택, 큐, 딕셔너리

> 스택, 큐, 딕셔너리의 원리와 구조



#### 큐

> 값이 아래로 쌓이는 구조

- **FIFO**: First in first out, 선입 선출
  - 배열이나 연결 리스트로 구현



#### 스택

> 값이 위로 쌓이는 구조

- **LIFO**: Last in first out, 후입 선출
  - 배열이나 연결 리스트로 구현



#### 딕셔너리

> 일반적으로 해시 테이블과 동일한 개념

- 키와 값으로 이루어짐



#### *생각해보기*

- *Q) 여태까지 배운 개념들을 기반으로 해서 나만의 새로운 자료 구조를 만들어 볼 수 있을까요?*
  - *A) 자료구조의 정의는 데이터의 특성에 따라 컴퓨터의 메모리 점유를 개선하기 위해 사용자가 만들 추상적 구조이므로 특정 데이터에 맞추어 새로운 자료 구조를 만들 수 있을 것*
  - 