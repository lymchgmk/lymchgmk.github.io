---
layout: post
title:  "모두를 위한 컴퓨터 과학 (CS50)"
summary: "Boostcourse / CS50"
author: lymchgmk
date: '2022-04-08 16:01:00 +0900'
category: Study
thumbnail: /assets/img/posts/CS50.png
keywords: Boostcourse
permalink: /blog/CS50
usemathjax: false
comments: true

---

# 모두를 위한 컴퓨터 과학 (CS50 2019)



## 1. 컴퓨팅 사고

### 1) 2진법

>  컴퓨터는 트랜지스터로 이루어져있고, 이 때문에 모든 데이터는 0과 1로 표현된다.



#### 컴퓨터 과학

> 문제 해결에 대한 학문. 입력을 전달받아 출력을 만들어내는 과정

- 입출력을 표현하기 위해 모두가 동의하는 표준이 필요.



#### 2진법

> 컴퓨터는 오로지 0과 1만으로 글자, 사진, 영상, 소리 등을 저장할 수 있음



#### 비트

> "binary digit", 0과 1, 두 가지 값만 가질 수 있는 측정 단위



#### 비트열

> 여러 숫자 조합을 컴퓨터에 나타내기 위한 비트의 모음

![img](D:\GITHUB\lymchgmk.github.io\assets\img\posts\CS50\1-1.png)



#### *생각해보기*

- *Q) 5를 2진법으로 바꿔보면 어떻게 될까요?*
  - *A) 101 (2)*





### 2) 정보의 표현

> 컴퓨터가 문자, 사진, 영상, 음악 등 다양한 정보를 처리하는 방식



#### 문자의 표현

> 문자를 숫자로 표현할 수 있도록 정해진 표준

- ASCII

  ![img](D:\GITHUB\lymchgmk.github.io\assets\img\posts\CS50\1-2.png)

  - A: 65로 시작하는 패턴. 미국의 규약. 당시 8bit만 사용한 한계.

- 유니코드
  - ASCII의 상위 조합. 이모티콘 포함. 32bit까지 사용.



#### 그림, 영상, 음악의 표현

> 그림, 영상, 음악은 어떻게 숫자로 표현하는가

- RGB
  - 이모티콘같은 이미지를 표현하기 위한 체계. RGB 3색을 조합하여 어떤 색이든 만들 수 있기 때문.
  - GIF같은 움직이는 이미지, 동영상도 마찬가지.
- ETC
  - 음악도 마찬가지로 양자화 가능. 음, 길이, 음량같은 정보를 0과 1로 표현.



#### *생각해보기*

- *Q) CS50을 2진법으로 표현해보세요*
  - *A) ASCII코드를 이용한 4자리 문자열로 생각한다면, 각각 십진수 67, 83, 53, 48에 해당하고, 이는 각각 이진수 1000011, 1010011, 1010101, 110000로 변환됨*





### 3) 알고리즘

> 일생 생활의 일을 컴퓨터가 이해할 수 있는 알고리즘으로 표현하고, 효율에 대해 설명



#### 알고리즘

> 입력값을 출력값으로 변환하기 위해 수행해야 하는 명령들의 순서적 나열

![algorithms](D:\GITHUB\lymchgmk.github.io\assets\img\posts\CS50\1-3.png)



#### 정확한 알고리즘

> 알고리즘을 평가할 때는 정확성과 효율성이 중요

- 전화번호에서 "Mike Smith"를 찾는 방법
  - 1. 첫 장부터 마지막 장까지 조회하는 방법을 옳지만 느리다.
    2. 두 장 씩 넘기는 것은 놓칠 수 있어서 틀리다.
  
- 사용자가 가지고 있는 직관이나 아이디어를 컴퓨터가 이해할 수 있는 방식으로 작성하는 것.
  - 이를 수도코드로 작성하고, 프로그래밍 언어로 만들면 됨.



#### 정확하고 효율적인 알고리즘

> 정확하다면 효율이 좋을 수록 좋다

- 이분탐색



#### 의사코드

> 필요한 행동이나 조건을 잘 설정하여 파악하기 위한 코드

- 함수
- 조건
  - 불리언
- 루프



#### *생각해보기*

- *Q) 친구와 1부터 100까지 숫자 중 1가지 숫자를 맞추는 스무고개 게임을 하려고 합니다. 이 때 사용할 알고리즘을 의사코드로 표현하면 어떻게 될까요?*

  - *A)*

    ```
    start, end = 1, 100
    target = 50
    while target != answer:
    	if target > answer:
    		end = target
    	else:
    		start = target
    	target = (end + start) // 2
    
    print(target)
    ```





### 4) 스크래치: 기초

> MIT에서 개발한 그래픽 프로그래밍 언어.

- 블럭을 이용해서, 입력과 출력을 이어 붙여 순차적인 작업을 수행.



### 5) 스크래치: 심화

- 스크래치를 이용해 보다 복잡한 알고리즘 구현







## 2. C언어

### 1) C 기초

> CS50 Sandbox를 이용해 Hello, world! 출력



#### C언어

> 아주 오래되고 전통적인 순수 텍스트 기반의 언어

```c
#include <stdio.h>

int main(void)
{
	printf("Hello, world!");
}
```



#### 컴파일러

> 소스 코드를 머신 코드로 변환하는 프로그램

![](D:\GITHUB\lymchgmk.github.io\assets\img\posts\CS50\2-1.png)

- source code -> `compiler` -> machine code(0과 1로만 이루어진 코드)
  - 터미널에서 `clang hello.c`로 c 소스코드를 컴파일, `a.out`파일을 생성
    - `./a.out`으로 결과 확인
  - `clang -o hello hello.c`로 생성파일의 이름 지정 옵션 가능.
  - 파일 위에 붙는`*`는 머신코드임을 의미

- `ls`: 현 디렉토리의 파일들 조회
- `rm [파일이름]`: 파일 삭제
- `rmdir`: 디렉토리 삭제



- 한글 윈도우에서는 백슬래시 `\`가 원화표기 `₩`로 보임.



#### *생각해보기*

- *Q) 아래의 실습하기로 "hello, boostcourse를 출력해보세요."*

  - *A)*

    ```c
    #include <stdio.h>
    
    int main(void)
    {
    	printf("hello, boostcourse\n");
    }
    ```





### 2) 문자열

> C언어로 문자열 형식을 가진 변수를 선언하고 출력



```c
#include <cs50.h>
#include <stdin.h>

int main(void)
{
	string answer = get_string("What's your name?\n");
	printf("hello, %s\n", answer);
}
```

- `clang -o string string.c -lcs50`
  - `-o [파일 이름]`: 머신코드 저장 명령어
  - `-l[라이브러리 이름]`: "link"를 의미하는 `-l`명령어를 이용해 cs50파일과 합침. 이를 통해 컴파일 시 cs50파일을 연결하도록 컴파일러에게 알려줌.
- `make string`: `string.c`파일을 알아서 컴파일 하도록 수행. 단, `.c`를 제외한 소스코드의 이름으로 실행시킬 것.



- `get_string`함수

  ```c
  string answer = get_string("What's your name?\n");
  ```

  - 변수를 선언할 때, 데이터 타입을 지정해줘야함.
  - `=`: 할당 연산자
  - `\n`: 개행문자

- `printf`함수

  ```c
  printf(hello, %s\n", answer);
  ```

  - `%s`: 문자열 형식 지정자(placeholder)



#### *생각해보기*

- *Q) "좋아하는 동물을 알려주세요"로 질문하여 동물 이름을 animal이라는 변수에 저장하고, 이를 "내가 좋아하는 동물은"으로 출력해주는 코드를 작성해보세요.*

  - *A)*

    ```c
    #include <stdio.h>
    #include <cs50.h>
    
    int main(void)
    {
        string animal = get_string("좋아하는 동물을 알려주세요.\n");
        printf("내가 좋아하는 동물은 %s입니다.\n", animal);
    }
    ```





### 3) 조건문과 루프

> 조건문과 루프를 C언어로 작성



#### 변수

- 변수 선언 및 증가

```c
int counter = 0;
counter = counter + 1;
counter += 1;
counter++;
```



#### 조건문

- 조건문 `if`

```c
if (x < y)
{
	printf("x is less than y\n");
}
else if (x > y)
{
	printf("x is greater than y\n");
}
else
{
	printf("x is equal to y\n");
}
```



#### 루프

- 루프 `while`

```c
int i = 0;
while (i < 50)
{
	printf("hello, world!\n");
	i = i + 1;
}
```



- 루프 `for`

```c
for (int i = 0; i < 50; i = i + 1)
{
	printf("hello, world!\n");
}
```



#### *생각해보기*

- *Q) 학습한 다양한 방법을 이용하여 "개발공부는 재미있다!를 10번 출력하는 코드를 작성해보세요."*

  - *A)*

    ```c
    #include <stdio.h>
    
    int main(void)
    {
    	for (int i=0; i<10; i++)
    	{
    		printf("개발공부는 재미있다!\n");
    	}
    }
    ```





### 4) 자료형, 형식 지정자, 연산자

> 다양한 데이터 타입과 형식 지정자 및 연산자를 이용한 조건문 표현



#### 데이터 타입

- 자료형
  - `bool` / `int`, `long` / `float`, `double` / `char`, `string` 
    - `int`는 대략 40억까지 가능하므로, 일부 거대 기업을 제외하고는 대부분 정수에 `int`를 사용.
- 형식 지정자
  - `%c: char`
  - `%f: float, double`
  - `%i: int`
  - `%li: long`
  - `%s`: string

- 연산자



#### CS50 라이브러리 내의 get 함수

> get_char, get_double, get_float, get_int, get_long, get_string

```c
# include <cs50.h>
# include <stdio.h>

int main(void)
{
    int age = get_int("what's your age?\n");
    printf("Your are at least %i days old.\n", age * 365);
}
```



#### 형식 지정자

> 각 데이터 타입을 위한 형식 지정자

- **%c** : char
- **%f** : float, double
- **%i** : int
- **%li** : long
- **%s** : string



#### 기타 연산자 및 주석

- +: 더하기
- -: 빼기
- *: 곱하기
- /: 나누기
- %: 나머지
- &&: 그리고
- ||: 또는
- //: 주석



#### 정수와 실수를 받아서 출력해보기

> %i, %f 형식 지정자를 사용



#### 짝수인지 홀수인지 알려주는 코드짜기

> 2로 나누어 나머지가 0이냐 1이냐로 판별



#### 주석

> C에서`//`를 사용한 주석



##### 참고) #include <cs50.h> 는 무엇인가요?

> CS50 수업을 위한 라이브러리

- 라이브러리: 여러 함수들을 모아둔 것
- 표준 라이브러리
  - `#include <stdio.h>`
  - 가장 많이 쓰고 가장 보편적으로 사용하는 라이브러리를 기본적으로 설치해놓음



#### *생각해보기*

- *Q) 짝수인지 홀수인지 알려주는 코드짜기에 자신의 스타일 대로 주석을 달아보고 다른 수강생은 어떠헥 주석을 달았는지 비교해보세요.*

  - *A)*

    ```c
    #include <cd50.h>
    #include <stdio.h>
    
    int main()
    {
    	// 변수 n 입력
    	int n = get_int("n: ");
    	
    	// 짝수인 경우
    	if (n%2==0)
    	{
    		printf("n is even");
    	}
    	// 홀수인 경우
    	else
    	{
    		printf("n is odd");
    	}
    }
    ```





### 5) 사용자 정의 함수, 중첩 루프

> 프로그램을 간결하게 하는 사용자 정의 함수의 사용



#### 사용자 정의 함수

> 동일한 작업을 반복

- 독립적인 기능은 사용자 정의 함수로 만들어서 사용
  - 그래야 `main`함수가 아래로 내려가지 않고 보기 좋음.

```c
#include <stdio.h>

void cough(int n);

int main(void)
{
    cough(3);
}

void cough(int n)
{
    for (int i = 0; i < n; i++)
    {
        printf("cough\n");
    }
}
```

- c언어는 오래되어 아래에 `cough`함수를 두면 에러가 발생.
  - 위에서 `cough`함수를 선언하고, `main`함수 아래에 `cough`함수를 구현하는 방식으로 작성
  - 선언부의 `int n`변수는 쓰레기 값(Garbage Value)를 가지고 있으니, 나중에 다시 제대로 넣어야 함.



#### 중첩 루프

> 여러 데이터를 가로나 세로로 반복하는 경우



#### *생각해보기*

- *Q) 사용자 정의 함수를 사용하는 것의 장점은 무엇일까요?*
  - *A) 반복되는 코드의 제거, 재사용 가능, 가독성 향상, 디버깅에 유리, 객체 지향적인 프로그래밍 가능*





### 6) 하드웨어의 한계

> 메모리 용량이 프로그램의 구동에 미치는 영향

- RAM은 **유한한 크기**의 비트만 저장할 수 있기 때문에 때때로 부정확한 결과를 내기도 함.



#### 부동 소수점 부정확성

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // 사용자에게 x 값 받기
    float x = get_float("x: ");

    // 사용자에게 y 값 받기
    float y = get_float("y: ");

    // 나눗셈 후 출력
    printf("x / y = %.50f\n", x / y);
}
```

```
// output
x: 1
y: 10
x / y = 0.10000000149011611938476562500000000000000000000000
```

- `float`에서 저장 가능한 비트 수가 유한하기 때문에 0.1이 아닌 다소 부정확한 결과를 냄



#### 정수 오버플로우

```c
#include <stdio.h>
#include <unistd.h>

int main(void)
{
    for (int i = 1; ; i *= 2)
    {
        printf("%i\n", i);
        sleep(1);
    }
```

```
// output
...
1073741824
overflow.c:6:25: runtime error: signed integer overflow: 1073741824 * 2 cannot be represented in type 'int'
-2147483648
0
0
...
```

- `int`는 32개의 비트만 가짐. 10억을 넘기자 앞으로 넘어갈 1의 자리가 없어져 그 이상의 숫자는 저장 불가.
  - "Y2K 문제"
  - 보잉 787에서 구동 후 248일이 지나면 모든 전력을 잃고 강제로 안전 모드로 진입하던 문제
    - 248일을 1/100초로 계산하면 대략 2^32였기 때문.
- 다루고자 하는 데이터 값의 범위를 유의하며 프로그램을 작성해야 한다.



#### *생각해보기*

- *Q) Y2K와 보잉787과 같은 문제를 방지하기 위해서는 프로그램을 어떻게 설계해야 할까요?*
  - *A)*
    - 1. *입력값의 크기에 맞는 넉넉한 자료형으로 변수 선언*
      2. *프로그래밍 실행 전 오버플로우 테스트*
      3. *오버플로우 예외처리*
      4. *오버플로우 발생시 초기화 실행*







## 3. 배열

### 1) 컴파일링

> 컴파일링의 4 단계, 전처리 / 컴파일링 / 어셈블링 / 링킹

- `main`함수: 프로그램의 시작점으로, 실행 버튼을 클릭하는 것과 같음
- `printf`함수: 출력을 담당하는 함수
  - `stdio.h`라이브러리: 헤더 파일. C언어로 작성되어 있으며 파일명이 `.h`로 끝남.



#### 전처리(Precompile)

> 컴파일 전, #include 실행

- 전처리기에 의해 수행.
  - 실질적인 컴파일 전에 무언가를 실행하라는 명령
- `#`으로 시작되는 C 소스 코드.
  - `#include`: 전처리기에 다른 파일의 내용을 포함하도록 명령
    - 전처리기는 새로운 파일(여전히 C 소스 코드)을 생성



#### 컴파일(Compile)

> 컴파일러가 C 소스 코드를 어셈블리 코드로 컴파일

- 컴퓨터가 이해할 수 있는 언어와 최대한 가까운 프로그램으로 만듦

- 소스코드에서 오브젝트 코드로 변환하는 전체 과정을 통틀어 의미하기도 하지만, 구체적으로 소스 코드를 어셈블리 코드로 변환하는 단계를 의미하기도 함.



#### 어셈블(Assemble)

> 어셈블러가 어셈플리 코드를 오브젝트 코드로 변환

- 연속된 0과 1들로 바꿔주는 작업
- 컴파일 해야하는 파일이 딱 한 개라면 여기서 끝나지만, 여러 개라면 링크라고 하는 단계가 추가됨.



#### 링크(Link)

>  여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합치는 단계.

- 추가적인 단계



#### *생각해보기*

- *Q) 만약 컴파일링 과정을 거치지 않기 위해 바로 머신코드로 우리가 원하는 프로그램을 작성하려고 한다면 어떤 문제가 있을까요?*
  - *A)*
    - 1. *가독성 난해로 인한 작업 능률 감소 및 디버깅 난이도 상승*
      2. *컴파일을 할 수 없으므로 프로그램 산출물에 대한 평가가 불가능*





### 2) 디버깅

> 코드에 있는 버그를 식별하고 고치는 과정



#### 버그와 디버깅

- `버그(Bug)`: 코드에 들어있는 오류
  - 실제 벌레에서 기원



#### 디버깅의 기본

- 프로그램을 한 행씩 실행하며 특정 행에서 멈추게 하고 (중지점) 단계별로 확인



##### help50

> CS50 IDE에서 컴파일시 생기는 오류를 해석해줌

```c
help50 make 파일이름
```



##### printf

- 직접 의심이 가는 변수를 출력해서 확인



##### debug50

> CS50 IDE에서 브레이크 포인트를 지정하고 소스파일을 컴파일 후 `debug50 파일이름`으로 디버깅 패널 사용



#### *생각해보기*

- *Q) 디버깅을 도와주는 프로그램은 어떤 경우에 더 큰 도움이 될까요? 만약 이런 프로그램의 도움 없이 직접 디버깅을 해야 한다면 어떻게 코드를 작성하는 것이 좋을까요?*
  - *A)*
    - *코드가 길고 복잡한 경우 디버깅을 도와주는 프로그램이 크게 도움이 됨. 버그의 이유, 버그의 종류 등을 확인하기 쉬움.*
    - *만약 디버깅 툴을 사용할 수 없다면, 기능별로 가능한 만큼 코드를 함수형으로 작성한 뒤, 출력을 이용해서 디버깅을 해야함.*





### 3) 코드의 디자인

> 코드의 정확성과 디자인을 관리하는 방법



##### check50

> CS50 IDE에서 과제 수행 확인 용 자동 검사 프로그램



##### style50

> CS50 IDE에서 코드의 심미성 검사, 스타일 가이드 확인



#### 고무 오리

> 내가 작성한 코드를 한 줄 씩 고무 오리같은 물체에게 설명해주며 스스로 디버깅





#### *생각해보기*

- *Q) 만약 여러 사람들이 함께 참여하는 프로젝트에서, 각자가 작성하는 코드 스타일이 서로 다르다면 어떤 비효율적인 일이 발생할까요?*
  - *A)*
    - *여러 코딩 컨벤션이 섞이면, 코드의 가독성이 떨어진다.*
    - *특히 들여쓰기의 space가 몇 칸인지, tab을 사용하는지에 따라 언어에 따라서는 오류가 발생하기도 하며, 이런 오류는 직접 찾기 매우 어렵다.*





### 4) 배열(1)

> 배열을 정의하고 사용하는 방법



#### 메모리

> 각각의 자료형은 서로 다른 크기의 메모리를 차지

- `bool: 1바이트`
- `char: 1바이트`
- `int: 4바이트`
- `float: 4바이트`
- `long: 8바이트`
- `double: 8바이트`
- `string: ?바이트`



#### 배열

> 같은 자료형의 데이터를 메모리에 연속적으로 저장하고, 이를 하나의 변수로 관리



#### *생각해보기*

- *Q) 실생활의 어떤 데이터를 배열로 표현할 수 있을까요?*
  - *A)*
    - *날씨, 시험 점수 등 속성이 명확하고 계량이 가능한 데이터*





### 5) 배열(2)

> 배열과 전역 변수



#### 전역 변수

> 코드 전반에 거쳐 바뀌지 않는 값

- `const int N = 3;`
  - 전역 변수의 이름은 대문자로 표기



#### 배열의 동적 선언 및 저장

- 배열의 크기를 사용자에게 입력 받고, 루프를 돌면서 인덱스를 이용해 입력 받은 값을 저장



#### *생각해보기*

- *Q) 점수의 평균을 구하는 예제에서, 동적으로 작성한 코드는 그렇지 않은 코드에 비해 어떤 장단점이 있을까요?*
  - *A)*
    - *동적으로 작성한 코드는 변수가 입력에 따라 자동으로 변하지만, 그렇지 않은 코드는 직접 변수에 값을 할당해줘야 한다.*
    - *높은 재사용성과 코드의 유연성*





### 6) 문자열과 배열

> 문자열이 C에서 정의되는 방식과 메모리에 저장되는 방식



- `string` 자료형은 사실 `char`자료형의 배열로 정의 됨.
  - 인덱스로 각 문자에 접근 가능



- 널 종단 문자
  - `ASCII`에서 0의 값을 가짐



#### *생각해보기*

- *Q) 널 종단 문자는 왜 필요할까요?*
  - *A)*
    - *문자열이 끝나는 위치를 추적, 문자열의 길이를 계산하는데 사용*
    - *널 종단 문자가 없는 경우, 메모리에 있는 문자열이 다음 메모리 데이터 블록을 침범할 수 있음*





### 7) 문자열의 활용

> 문자열을 탐색하고 일부 문자를 수정



#### 문자열의 길이 및 탐색

- 문자열의 끝은, 해당 인덱스의 문자가 널 종단 문자(`\0`)과 일치하는지 검사하면 알 수 있다.
  - 혹은, `string.h` 라이브러리의 `strlen()` 함수를 사용

```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string s = get_string("Input: ");
    printf("Output:\n");
    for (int i = 0, n = strlen(s); i < n; i++)
    {
        printf("%c\n", s[i]);
    }
}
```



#### 문자열 탐색 및 수정

- `ASCII`값으로 영문자 소문자는 대문자보다 32씩 큼
  - `ctype.h`라이브러리의 `toupper()` 함수





####  *생각해보기*

- *Q) string.h와 ctype.h의 라이브러리에 다른 어떤 함수가 있는지 확인해 보고, 어떤 함수를 어떻게 활용해 볼 수 있을지 생각해봅시다.*
  - *A)*
    - *문자열이 끝나는 위치를 추적, 문자열의 길이를 계산하는데 사용*
    - *널 종단 문자가 없는 경우, 메모리에 있는 문자열이 다음 메모리 데이터 블록을 침범할 수 있음*





### 8) 명령행 인자

> `make`나 `clang`같은 명령에, 옵션을 추가할 수 있음.

- `main`함수에 `int argc`, `string argv[]`를 변수로 입력 받을 수 있음
  - `argc`: 입력의 개수
  - `argv[]`: 입력이 포함된 배열
    - `argv[0]`는 기본적으로 프로그램의 이름



#### *생각해보기*

- *Q) 명령행 인자는 프로그램의 확장성에 어떤 도움이 될까요? 구체적인 예시를 떠올려보세요.*
  - *A)*
    - *사용자나 다른 프로그램에 입력 데이터를 전달할 수 있다.*
      - *만약, 전달되지 않는 경우 이를 감지하고 사용자에게 입력을 요청하도록 하여 확정성에 도움이 된다.*







## 4. 알고리즘



### 1) 검색 알고리즘

> 주어진 배열에서 특정 값을 찾기



#### 선형 검색

> 인덱스를 처음부터 끝까지 하나씩 증가시키며 검사



#### 이진 검색

> 배열이 정렬되어 있는 경우, 찾고자 하는 값과 남은 배열의 중간 값을 비교하며 이동



#### *생각해보기*

- *Q) 만약 정렬되지 않은 배열이 있다면, 선형 검색이 빠를까요 이진 검색이 빠를까요?*
  - *A)*
    - *정렬하지 않고 검색을 한다면 이진 검색은 불가능하고 선형 검색만 사용가능하며, 정렬 후 검색한다면 충분히 배열이 크다는 전제하에 이진 검색이 빠르다.*





### 2) 알고리즘 표기법

> 알고리즘 실행 시간의 상한과 하한



- **Big O** 표기법: 알고리즘 실행 시간의 **상한**
  - O는 "on the order of"의 약자
- **Big  Ω** 표기법: 알고리즘 실행 시간의 **하한**



#### *생각해보기*

- *Q) 실행시간의 상한이 낮은 알고리즘이 더 좋을까요, 하한이 낮은 알고리즘이 더 좋을까요?*
  - *A)*
    - *경우에 따라 다르지만 일반적으로는 최악의 경우를 상정하기 때문에, 상한이 낮은 알고리즘을 선호한다.*





### 3) 선형 검색

> 주어진 배열 또는 구조체에서 선형 검색



#### 선형 검색

> 원하는 원소가 발견될 때까지 처음부터 마지막 자료까지 차례대로 검색



#### 효율성 그리고 비효율성

- 선형 검색 알고리즘은 정확하지만 비효율적
  - 자료가 정렬되어 있지 않거나, 그 어떤 정보도 없는 경우 유용

- **구조체**를 정의해서 더 확장성있고 효율적인 검색 프로그램 가능
  - 예를 들어, 전화번호부에 이름과 번호를 묶어서 구조체로 정의



#### *생각해보기*

- *Q) 전화번호부와 같이 구조체를 정의하여 관리 및 검색을 하면 더 편리한 예는 또 무엇이 있을까요?*
  - *A)*
    - *사용자의 회원 정보와 같이, 여러 관련있는 속성을 한꺼번에 관리해야 하는 경우에 구조체가 유리하다.*





### 4) 버블 정렬

> 버블 정렬의 원리와 실행 시간 및 구현



#### 버블 정렬

> 두 개의 인접한 자료 값을 비교하면서 위치를 교환

- 인접한 두 수를 계속 비교하는 것을 n번 수행

- **O(n^2)**
- **Ω(n^2)**



#### *생각해보기*

- *Q) 버블 정렬이 효율적인 경우는 어떤 경우인가요? 반대로 어떤 경우에 비효율적이게 될까요?*
  - *A)*
    - *배열의 메모리가 클 때, 버블 정렬은 제자리에 데이터를 교환하므로 메모리 누수가 거의 없는 장점이 있다.*
    - *최선이든 최악이든 O(n^2)의 시간복잡도를 가지므로, 배열이 클 수록 비효율적이며, 데이터가 역순으로 정렬되어 있을 경우 가장 교환 횟수가 많다.*





### 5) 선택 정렬

> 선택 정렬의 원리와 실행 시간 및 구현



#### 선택 정렬

> 배열 안의 자료 중 가장 작은(혹은 가장 큰) 수를 찾아 첫 번째 위치(혹은 마지막 위치)와 교환

- 자리를 처음부터 마지막까지 따라가며, 그 자리에 맞는 작은 수를 배열에서 찾아오는 방식

- **O(n^2)**
- **Ω(n^2)**



#### *생각해보기*

- *Q) 선택정렬을 좀 더 효율적으로 어떻게 바꿀 수 있을까요?*
  - *A)*
    - 1. *이중 선택 정렬: 한 번의 탐색에서 최솟값과 최댓값을 같이 찾는 방법. 탐색 횟수를 절반으로 줄일 수 있다.*
      2. *탐색을 응용하여 개선: 한 번의 탐색 때 동일한 값이 있다면 함께 정렬하는 방법. 같은 값이 많을수록 유리.*





### 6) 정렬 알고리즘의 실행시간

> 여러 정렬 알고리즘과 검색 알고리즘의 실행 시간을 Big O와 Big Ω로 정의



#### 실행시간의 상한

- **O(n^2)**: 선택 정렬, 버블 정렬
- **O(n log n)**
- **O(n)**: 선형 검색
- **O(log n)**: 이진 검색
- **O(1)**



#### 실행시간의 하한

- **Ω(n^2)**: 선택 정렬, (일반적인 상황의) 버블 정렬
- **Ω(n log n)**
- **Ω(n)**: (교환이 일어나지 않는 경우의) 버블 정렬
- **Ω(log n)**
- **Ω(1)**: 선형 검색, 이진 검색



#### *생각해보기*

- *Q) 선택 정렬의 실행 시간의 하한도 버블 정렬처럼 더 단축시킬 수 있을까요?*
  - *A)*
    - *교환이 이루어지지 않아도 배열 전체를 계속 탐색하기 때문에 불가능.*





### 7) 재귀

> 함수를 재귀적으로 사용하는 코드를 작성



#### 재귀

> 함수가 본인 스스로를 호출해서 사용



#### *생각해보기*

- *Q) 반복문을 쓸 수 있는데도 재귀를 사용하는 이유는 무엇일까요?*
  - *A)*
    - *변수를 여럿 만들 필요가 없고, 코드가 간결해짐*
    - *프로그램 작성 시 직관적인 이해에 도움이 됨*





### 8) 병합 정렬

> 재귀를 활용한 병합 정렬 구현



#### 병합 정렬

> 원소가 한 개가 될 때까지 계속해서 반으로 나누고, 다시 합쳐가며 정렬

- **O(n log n)**
-  **Ω(n log n)**



#### *생각해보기*

- *Q) 병합 정렬을 선택 정렬이나 버블 정렬과 비교했을 때 장점과 단점은 무엇이 있을까요?*
  - *A)*
    - *장점*
      - *선택 정렬은 불안정 정렬이지만, 병합 정렬은 안정 정렬*
      - *O(log n)의 시간복잡도*
      - *연결 리스트로 구성하면, 링크 인덱스만 변경되므로 차지하는 메모리를 크게 줄일 수 있다.*
    - *단점*
      - *배열로 구성된 경우, 분할한 배열로 인한 높은 메모리 차지*

